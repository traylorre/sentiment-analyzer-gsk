# Flush Local Branches to Origin

Push all local feature branches to origin and create PRs for any that are ahead of main. Clean up merged branches.

## Goal

Prevent the pattern of: debug issue → implement fix → forget to push → issue re-encountered.

Ensures all local work is:
1. Pushed to origin
2. Has a PR created (if ahead of main)
3. Merged branches are cleaned up locally

## Execution Steps

### Step 1: Identify All Local Branches

```bash
git fetch origin main
git branch -vv
```

Create inventory of branches:
| Branch | Tracking | Ahead of Main? | Has Open PR? | Action Needed |
|--------|----------|----------------|--------------|---------------|

### Step 2: For Each Local Branch (except main)

For each branch that has unpushed commits or is ahead of origin/main:

1. **Check if branch exists on origin:**
   ```bash
   git ls-remote --heads origin <branch-name>
   ```

2. **Push to origin (if needed):**
   ```bash
   git push origin <branch-name>
   ```

3. **Check for existing PR:**
   ```bash
   gh pr list --head <branch-name> --state open --json number,title
   ```

4. **Create PR if none exists and branch is ahead of main:**
   ```bash
   gh pr create --title "<auto-generated from branch/commits>" --base main
   ```

### Step 3: Report Open PRs

List all open PRs that need attention:
```bash
gh pr list --state open --json number,title,headRefName,url
```

### Step 4: Clean Up Merged Branches

Detect branches that are fully merged into main. This includes:
1. **Fast-forward/regular merges**: Detected by `git branch --merged`
2. **Squash merges**: Detected by comparing tree content (branch diff vs main is empty)

```bash
# Method 1: Find traditionally merged branches
git branch --merged origin/main | grep -v "main\|master\|\*"

# Method 2: Find squash-merged branches (content already in main)
# A branch is squash-merged if cherry-picking it onto main produces no changes
for branch in $(git branch --format='%(refname:short)' | grep -v "^main$"); do
  # Skip if traditionally merged (already caught above)
  if git branch --merged origin/main | grep -q "^[* ]*${branch}$"; then
    continue
  fi

  # Check if branch content is already in main by comparing commits
  # Use two dots (..) to compare the branch tip to main tip
  # If git diff shows nothing, the branch content is fully in main
  if git diff origin/main.."$branch" --quiet 2>/dev/null; then
    echo "$branch (squash-merged)"
  fi
done
```

For each merged branch:
```bash
# Delete local merged branches
git branch -d <branch-name>

# For squash-merged branches, may need -D since git doesn't recognize the merge
git branch -D <branch-name>

# Delete remote merged branches (optional, with confirmation)
git push origin --delete <branch-name>
```

## Output Format

```markdown
## Branch Flush Report

### Pushed to Origin
| Branch | Commits Pushed | PR Created/Exists |
|--------|----------------|-------------------|

### Open PRs Requiring Review
| PR # | Title | Branch | URL |
|------|-------|--------|-----|

### Cleaned Up (Merged)
| Branch | Merge Type | Deleted Local | Deleted Remote |
|--------|------------|---------------|----------------|

### Errors/Warnings
- ...
```

## Safety Guards

- Never force push without explicit user confirmation
- Never delete branches that aren't fully merged (check both regular and squash merges)
- Always rebase on main before pushing (to avoid merge conflicts in PR)
- Skip branches with uncommitted changes (warn user)
- For squash-merged branches, confirm with user before deletion (since `git branch -d` won't work)

## Quick Commands

**Push all local branches to origin:**
```bash
for branch in $(git branch --format='%(refname:short)' | grep -v main); do
  echo "Pushing $branch..."
  git push origin "$branch" 2>/dev/null || echo "  (already up to date or error)"
done
```

**List branches ahead of main with no PR:**
```bash
for branch in $(git branch --format='%(refname:short)' | grep -v main); do
  ahead=$(git rev-list --count origin/main.."$branch" 2>/dev/null || echo 0)
  if [ "$ahead" -gt 0 ]; then
    pr=$(gh pr list --head "$branch" --state open --json number -q '.[0].number' 2>/dev/null)
    if [ -z "$pr" ]; then
      echo "$branch: $ahead commits ahead, NO PR"
    else
      echo "$branch: $ahead commits ahead, PR #$pr"
    fi
  fi
done
```

## Automatic Execution

When invoked, automatically:

1. Fetch latest from origin
2. Identify all local branches with unpushed work
3. Push each branch to origin
4. Create PRs for branches ahead of main without existing PRs
5. List all open PRs for review
6. Detect merged branches (both regular and squash merges)
7. Offer to clean up merged branches (with user confirmation for squash merges)

Report results in a clear table format.

### Squash Merge Detection Logic

A branch is considered squash-merged when:
- `git diff origin/main..<branch>` produces no output (branch tip is identical to main tip)
- But `git branch --merged origin/main` doesn't list it (commits weren't fast-forwarded)

This catches the common GitHub "Squash and merge" workflow where commit SHAs change.
